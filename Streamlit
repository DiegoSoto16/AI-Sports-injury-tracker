import streamlit as st
import pandas as pd
import datetime
import requests
import random
import plotly.express as px
from typing import Dict
from streamlit_calendar import calendar

if "data_initialized" not in st.session_state:
    # Default simulated single-day data
    st.session_state.wearable_data = {
        "heart_rate": 82,
        "fatigue_level": 4,
        "sleep_hours": 7.5,
        "steps": 8300,
        "calories_burned": 520,
    }

    # Generate 14 days of mock historical data
    today = pd.Timestamp.today()
    st.session_state.historical_data = pd.DataFrame({
        "Date": pd.date_range(end=today, periods=14),
        "Heart Rate": [random.randint(70, 90) for _ in range(14)],
        "Sleep Hours": [round(random.uniform(6, 8.5), 1) for _ in range(14)],
        "Steps": [random.randint(6000, 11000) for _ in range(14)],
        "Calories Burned": [random.randint(400, 600) for _ in range(14)],
    })

    st.session_state.events = []
    st.session_state.user_profile = {
        "name": "Athlete One",
        "age": 25,
        "sport": "Soccer",
        "training_goal": "Injury Prevention & Performance",
    }

    st.session_state.data_initialized = True

# ------------------------ Utility Functions ------------------------

def fetch_backend_data() -> Dict:
    """Try fetching wearable data from backend; fallback to simulation."""
    try:
        response = requests.get("http://localhost:8000/api/metrics/")
        if response.status_code == 200:
            return response.json()
        else:
            st.warning("âš ï¸ Backend returned an error, using simulated data.")
    except Exception:
        st.warning("âš ï¸ Backend not reachable, using simulated data.")
    return st.session_state.wearable_data


def compute_ai_metrics(data: Dict) -> Dict:
    """Compute risk and strain metrics (formula-based)."""
    hr = data.get("heart_rate", 80)
    fatigue = data.get("fatigue_level", 4)
    sleep = data.get("sleep_hours", 7)
    steps = data.get("steps", 8000)

    risk_score = min(1, ((hr - 60) / 100 + fatigue / 10 - sleep / 15))
    risk_score = max(0, round(risk_score, 2))

    strain_score = min(1, ((steps / 10000) + (hr / 200)) / 2)
    strain_score = max(0, round(strain_score, 2))

    return {"risk_level": risk_score, "strain_level": strain_score}


def generate_ai_advice(data: Dict) -> Dict:
    """Unified AI logic: use compute_ai_metrics for risk, then add advice."""
    metrics = compute_ai_metrics(data)
    risk_score = metrics["risk_level"]

    hr, fatigue, sleep = data["heart_rate"], data["fatigue_level"], data["sleep_hours"]

    if risk_score > 0.7 or hr > 160 or fatigue > 8:
        advice = [
            "Your heart rate and fatigue suggest overtraining.",
            "Take a recovery day and hydrate well.",
            "Avoid intense sessions until metrics stabilize.",
        ]
    elif risk_score > 0.4 or sleep < 6 or fatigue > 6:
        advice = [
            "Youâ€™re moderately fatiguedâ€”consider a lighter workout.",
            "Prioritize sleep and hydration tonight.",
            "Mobility or low-impact cardio is ideal today.",
        ]
    else:
        advice = [
            "Metrics look goodâ€”you're ready to train.",
            "Stick to your plan and monitor recovery.",
            "Keep syncing your wearable for better insights.",
        ]

    return {"risk_score": risk_score, "advice": advice}

# ------------------------ Sidebar Navigation ------------------------

st.sidebar.title("Navigation")
page = st.sidebar.radio(
    "Go to",
    ["ğŸ  Dashboard", "ğŸ“… Calendar", "ğŸ§  AI Prevention", "âŒš Wearable Devices", "ğŸ‘¤ Profile"],
)

# ------------------------ Dashboard ------------------------

if page == "ğŸ  Dashboard":
    st.title("ğŸ“Š Athlete Health Dashboard")

    # Try backend first
    wearable_data = fetch_backend_data()
    st.session_state.wearable_data = wearable_data
    metrics = compute_ai_metrics(wearable_data)

    # Main stats
    col1, col2, col3 = st.columns(3)
    col1.metric("â¤ï¸ Heart Rate", f"{wearable_data['heart_rate']} bpm")
    col2.metric("ğŸ’¤ Sleep Hours", wearable_data["sleep_hours"])
    col3.metric("ğŸ”¥ Calories Burned", wearable_data["calories_burned"])

    col4, col5, col6 = st.columns(3)
    col4.metric("ğŸƒ Steps", wearable_data["steps"])
    col5.metric("âš ï¸ Risk Level", f"{metrics['risk_level']*100:.1f}%")
    col6.metric("ğŸ’ª Strain Level", f"{metrics['strain_level']*100:.1f}%")

    st.divider()
    st.subheader("ğŸ“ˆ Performance Trends")

    # Plot historical charts
    hist = st.session_state.historical_data

    col_a, col_b = st.columns(2)
    with col_a:
        st.plotly_chart(px.line(hist, x="Date", y="Heart Rate", title="Heart Rate Trend"), use_container_width=True)
        st.plotly_chart(px.bar(hist, x="Date", y="Steps", title="Daily Steps"), use_container_width=True)
    with col_b:
        st.plotly_chart(px.bar(hist, x="Date", y="Sleep Hours", title="Sleep Duration"), use_container_width=True)
        st.plotly_chart(px.line(hist, x="Date", y="Calories Burned", title="Calories Burned Trend"), use_container_width=True)

# ------------------------ AI Prevention Page ------------------------

elif page == "ğŸ§  AI Prevention":
    st.title("ğŸ§  AI Injury Prevention Advisor")

    wearable_data = st.session_state.wearable_data

    try:
        response = requests.post("http://localhost:8000/api/advice/", json=wearable_data)
        if response.status_code == 200:
            ai_response = response.json()
        else:
            st.warning("âš ï¸ Backend AI unavailable â€” using local AI simulation.")
            ai_response = generate_ai_advice(wearable_data)
    except Exception:
        st.warning("âš ï¸ Could not connect to AI backend â€” using simulation.")
        ai_response = generate_ai_advice(wearable_data)

    risk_score = ai_response["risk_score"]
    st.metric("Injury Risk Score", f"{risk_score*100:.1f}%")

    if risk_score > 0.7:
        st.error("ğŸš¨ High Risk â€” rest and recovery recommended.")
    elif risk_score > 0.4:
        st.warning("âš ï¸ Moderate Risk â€” reduce intensity.")
    else:
        st.success("âœ… Low Risk â€” safe to train.")

    st.subheader("Personalized Training Advice")
    for tip in ai_response["advice"]:
        st.write(f"- {tip}")

# ------------------------ Calendar ------------------------

elif page == "ğŸ“… Calendar":
    st.title("ğŸ“… Training & Recovery Calendar")

    st.subheader("Add Event")
    event_title = st.text_input("Event Title")
    event_date = st.date_input("Event Date", datetime.date.today())

    if st.button("Add Event"):
        st.session_state.events.append({"title": event_title, "start": str(event_date), "end": str(event_date)})
        st.success(f"Event '{event_title}' added!")

    st.subheader("Your Calendar")
    calendar(events=st.session_state.events)

# ------------------------ Wearable Devices ------------------------

elif page == "âŒš Wearable Devices":
    st.title("âŒš Connected Wearables")

    st.markdown("**Currently Connected:**")
    devices = ["Fitbit Charge 5", "Apple Watch Series 8"]
    for d in devices:
        st.write(f"- {d}")

    if st.button("Send Data to Backend"):
        try:
            response = requests.post(
                "http://localhost:8000/api/metrics/",
                json=st.session_state.wearable_data
            )
            if response.status_code == 201:
                st.success("âœ… Data sent successfully!")
            else:
                st.error("âŒ Failed to send data.")
        except Exception as e:
            st.error(f"Error sending data: {e}")

# ------------------------ Profile ------------------------

elif page == "ğŸ‘¤ Profile":
    st.title("ğŸ‘¤ User Profile")

    profile = st.session_state.user_profile
    name = st.text_input("Name", profile["name"])
    age = st.number_input("Age", 10, 100, profile["age"])
    sport = st.text_input("Sport", profile["sport"])
    goal = st.text_input("Training Goal", profile["training_goal"])

    if st.button("Update Profile"):
        st.session_state.user_profile = {
            "name": name,
            "age": age,
            "sport": sport,
            "training_goal": goal,
        }
        st.success("âœ… Profile updated!")

    st.markdown("### Current Profile")
    for k, v in st.session_state.user_profile.items():
        st.write(f"**{k.title()}**: {v}")
